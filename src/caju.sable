Package caju;

// ----------------------------------------------------------------------------
// Léxico.

Helpers
  digito = ['0' .. '9'];
  espaco = ' ';
  underscore = '_';
  lf = 10;
  rc = 13;
  eol = (lf | rc | lf rc);
  delim = (espaco | lf | rc);
  letra = ['A' .. 'Z'] | ['a' .. 'z'];
  ascii = [0 .. 0xffff];
  ascii_but_eol = [ascii - [lf + rc]];
  ascii_but_bracket = [ascii - '}'];

Tokens
  comentario_linha = '#' ascii_but_eol* eol;
  comentario_bloco = '{' ascii_but_bracket* '}';
  tipo_caractere = 'caractere';
  tipo_numero = 'numero';
  tipo_booleano = 'booleano';
  tipo_vetor = 'vetor';
  tipo_vazio = 'vazio';
  bloco_i = 'inicio';
  bloco_f = 'fim';
  ctr_enquanto = 'enquanto';
  ctr_para_cada = 'para cada';
  ctr_para_cada_sep = ':';
  ctr_para = 'para';
  ctr_se = 'se';
  ctr_senao = 'senao';
  sbrt_retorne = 'retorne';
  virg = ',';
  indicador_comeco = '->';
  sep_for = ';';
  sep_arg = '|';
  mais = '+';
  menos = '-';
  mult = '*';
  div = '/';
  atribuicao = ':=';
  ponto = '.';
  menor = '<';
  maior = '>';
  menor_igual = '<=';
  maior_igual = '>=';
  igual = '=';
  bool_nao = 'nao';
  bool_e = 'e';
  bool_ou = 'ou';
  bool_se = 'se';
  par_esq = '(';
  par_dir = ')';
  colch_esq = '[';
  colch_dir = ']';
  caractere = ''' ('\')? ascii ''';
  string = '"' [ascii - '"']* '"'; 
  numero = digito+ (',' digito+)?;
  booleano = 'verdadeiro' | 'falso'; 
  identificador = letra (letra | underscore | digito)*;
  ws = delim+;

Ignored Tokens
  ws, comentario_linha, comentario_bloco;


// ----------------------------------------------------------------------------
// Sintático.

Productions

programa = dec_variavel* dec_funcao*;

dec_variavel = tipo lista_nomes ponto;

lista_nomes = identificador virg_id_fecho*;

virg_id_fecho = virg identificador;

tipo = {tipo_base} tipo_base
      | {tipo_vetor} tipo_vetor tipo_base colch_exp_colch+;

colch_exp_colch = colch_esq exp colch_dir;

tipo_base = {tipo_num} tipo_numero 
          | {tipo_char} tipo_caractere
          | {tipo_bool} tipo_booleano;

dec_funcao = indicador_comeco? tipo_retorno identificador par_esq parametros par_dir bloco;

tipo_retorno = {tipo} tipo
              | {tipo_vazio} tipo_vazio;

parametros = {param} parametro parametro_fecho*
            | {empty};

parametro_fecho = sep_arg parametro;

parametro = tipo identificador;

bloco = bloco_i dec_variavel* comando* bloco_f;

atrib = var atribuicao exp;

lista_atrib = atrib virg_atrib_fecho*;

virg_atrib_fecho = virg atrib;

comando = {comando_casam} comando_casam
        | {comando_nao_casam} comando_nao_casam;

comando_nao_casam = {comando_se_senao} ctr_se par_esq exp par_dir [esq]:comando_nao_casam ctr_senao [dir]:comando_nao_casam
        | {comando_atrib} atrib ponto
        | {comando_retorne} sbrt_retorne exp? ponto
        | {comando_bloco} bloco
        | {comando_chamada} chamada ponto;

comando_casam = {comando_se} ctr_se par_esq exp par_dir comando
              | {comando_se_senao} ctr_se par_esq exp par_dir comando_nao_casam ctr_senao comando_casam
              | {comando_enquanto} ctr_enquanto par_esq exp par_dir comando
              | {comando_para} ctr_para par_esq [esq1]:lista_atrib [esq2]:sep_for exp [dir1]:sep_for [dir2]:lista_atrib par_dir comando
              | {comando_para_cada} ctr_para_cada par_esq tipo [esq1]:identificador ctr_para_cada_sep [esq2]:identificador par_dir comando;


var = {id} identificador
      | {var2} var colch_esq exp colch_dir;

chamada = identificador par_esq lista_exp par_dir;

exp = {exp_ou} exp_ou;

exp_ou = {exp_ou} exp_ou bool_ou exp_e
      | {exp_e} exp_e;

exp_e = {exp_e} exp_e bool_e exp_comparativa
      | {exp_comparativa} exp_comparativa;

exp_comparativa = {igual} exp_comparativa igual exp_soma_sub
      | {menor_igual} exp_comparativa menor_igual exp_soma_sub
      | {maior_igual} exp_comparativa maior_igual exp_soma_sub
      | {menor} exp_comparativa menor exp_soma_sub
      | {maior} exp_comparativa maior exp_soma_sub
      | {exp_soma_sub} exp_soma_sub;

exp_soma_sub = {soma} exp_soma_sub mais exp_mult_div
      | {subtracao} exp_soma_sub menos exp_mult_div
      | {exp_mult_div} exp_mult_div;

exp_mult_div = {mult} exp_mult_div mult exp_nao
      | {div} exp_mult_div div exp_nao
      | {exp_nao} exp_nao;

exp_nao = {exp_nao} bool_nao exp_nao
      | {exp_parentese_literais} exp_parentese_literais;    

exp_parentese_literais = {exp_parentese} par_esq exp par_dir
      | {var} var 
      | {num} numero_pos_neg
      | {char} caractere
      | {bool} booleano
      | {string} string
      | {chamada} chamada;


numero_pos_neg = {num_pos} numero
                | {num_neg} menos numero;

operador_comparativo = {igual} igual
            | {menor_igual} menor_igual
            | {maior_igual} maior_igual
            | {menor} menor
            | {maior} maior;

lista_exp = {lista_exp} exp sep_exp_fecho*
          | {empty};

sep_exp_fecho = sep_arg exp;
