Package caju;

// ----------------------------------------------------------------------------
// Léxico.

Helpers
  digito = ['0' .. '9'];
  espaco = ' ';
  underscore = '_';
  lf = 10;
  rc = 13;
  eol = (lf | rc | lf rc);
  delim = (espaco | lf | rc);
  letra = ['A' .. 'Z'] | ['a' .. 'z'];
  ascii = [0 .. 0xffff];
  ascii_but_eol = [ascii - [lf + rc]];
  ascii_but_bracket = [ascii - '}'];

Tokens
  comentario_linha = '#' ascii_but_eol* eol;
  comentario_bloco = '{' ascii_but_bracket* '}';
  tipo_caractere = 'caractere';
  tipo_numero = 'numero';
  tipo_booleano = 'booleano';
  tipo_vetor = 'vetor';
  tipo_vazio = 'vazio';
  bloco_i = 'inicio';
  bloco_f = 'fim';
  ctr_enquanto = 'enquanto';
  ctr_para_cada = 'para cada';
  ctr_para_cada_sep = ':';
  ctr_para = 'para';
  ctr_se = 'se';
  ctr_senao = 'senao';
  sbrt_retorne = 'retorne';
  virg = ',';
  indicador_comeco = '->';
  sep_for = ';';
  sep_arg = '|';
  mais = '+';
  menos = '-';
  mult = '*';
  div = '/';
  atribuicao = ':=';
  ponto = '.';
  menor = '<';
  maior = '>';
  menor_igual = '<=';
  maior_igual = '>=';
  igual = '=';
  bool_nao = 'nao';
  bool_e = 'e';
  bool_ou = 'ou';
  bool_se = 'se';
  par_esq = '(';
  par_dir = ')';
  chave_esq = '[';
  chave_dir = ']';
  caractere = ''' ('\')? ascii ''';
  string = '"' [ascii - '"']* '"'; 
  numero = digito+ (',' digito+)?;
  booleano = 'verdadeiro' | 'falso'; 
  identificador = letra (letra | underscore | digito)*;
  ws = delim+;

Ignored Tokens
  ws, comentario_linha, comentario_bloco;


// ----------------------------------------------------------------------------
// Sintático.

Productions

programa = dec_variavel* dec_funcao*;

dec_variavel = tipo lista_nomes ponto;

lista_nomes = identificador virg_id_fecho*;

virg_id_fecho = virg identificador;

tipo = {tipo_base} tipo_base
      | {tipo_vetor} tipo_vetor tipo_base [esq]:chave_exp_chave [dir]:chave_exp_chave*;

chave_exp_chave = chave_esq exp chave_dir;

tipo_base = {tipo_num} tipo_numero 
          | {tipo_char} tipo_caractere
          | {tipo_bool} tipo_booleano;

dec_funcao = indicador_comeco? tipo_retorno identificador par_esq parametros par_dir bloco;

tipo_retorno = {tipo} tipo
              | {tipo_vazio} tipo_vazio;

parametros = {param} parametro parametro_fecho*
            | {empty};

parametro_fecho = sep_arg parametro;

parametro = tipo identificador;

bloco = bloco_i dec_variavel* comando* bloco_f;

atrib = var atribuicao exp;

lista_atrib = atrib virg_atrib_fecho*;

virg_atrib_fecho = virg atrib;

comando = {dec_casam} dec_casam 
         | {dec_nao_casam} dec_nao_casam
         | {comando1} comando1;

dec_casam = {comando_se_senao_casam} ctr_se par_esq exp par_dir [esq]:dec_casam ctr_senao [dir]:dec_casam;

dec_nao_casam = {comando_se_nao_casam} ctr_se par_esq exp par_dir comando
                | {comando_se_senao_nao_casam} ctr_se par_esq exp par_dir dec_casam ctr_senao dec_nao_casam;

comando1 = {comando_enquanto} ctr_enquanto par_esq exp par_dir comando
        | {comando_para} ctr_para par_esq [esq1]:lista_atrib [esq2]:sep_for exp [dir1]:sep_for [dir2]:lista_atrib par_dir comando
        | {comando_para_cada} ctr_para_cada par_esq tipo [esq1]:identificador ctr_para_cada_sep [esq2]:identificador par_dir comando
        | {comando_atrib} atrib ponto
        | {comando_retorne} sbrt_retorne exp* ponto
        | {comando_bloco} bloco
        | {comando_chamada} chamada ponto;

var = identificador chave_exp_chave*;

chamada = identificador par_esq lista_exp par_dir;

exp = {exp_ou} exp bool_ou exp2
      | {exp2} exp2;

exp2 = {exp_e} exp2 bool_e exp3
      | {exp3} exp3;

exp3 = {exp_igual} exp3 igual exp4
      | {exp_menor_igual} exp3 menor_igual exp4 
      | {exp_maior_igual} exp3 maior_igual exp4
      | {exp_menor} exp3 menor exp4
      | {exp_amaior} exp3 maior exp4
      | {exp4} exp4;

exp4 = {exp_soma} exp4 soma_sub exp5
      | {exp5} exp5;

soma_sub = {soma} mais 
          | {subtracao} menos;

exp5 = {exp_mult} exp5 mult_div exp6
      | {exp6} exp6;

mult_div = {mult} mult
          | {div} div;

exp6 = {exp_nao} bool_nao exp7
      | {exp7} exp7;

exp7 = {exp_parentese} par_esq exp par_dir 
      | {num} numero
      | {char} caractere
      | {bool} booleano
      | {exp_var} var
      | {chamada} chamada;

lista_exp = {lista_exp} exp sep_exp_fecho*
          | {empty};

sep_exp_fecho = sep_arg exp;
