Package caju;

// ----------------------------------------------------------------------------
// Léxico.

Helpers
  digito = ['0' .. '9'];
  espaco = ' ';
  underscore = '_';
  lf = 10;
  rc = 13;
  eol = (lf | rc | lf rc);
  delim = (espaco | lf | rc);
  letra = ['A' .. 'Z'] | ['a' .. 'z'];
  ascii = [0 .. 0xffff];
  ascii_but_eol = [ascii - [lf + rc]];
  ascii_but_bracket = [ascii - '}'];

Tokens
  comentario_linha = '#' ascii_but_eol* eol;
  comentario_bloco = '{' ascii_but_bracket* '}';
  tipo_caractere = 'caractere';
  tipo_numero = 'numero';
  tipo_booleano = 'booleano';
  tipo_vetor = 'vetor';
  tipo_vazio = 'vazio';
  bloco_i = 'inicio';
  bloco_f = 'fim';
  ctr_enquanto = 'enquanto';
  ctr_para_cada = 'para cada';
  ctr_para_cada_sep = ':';
  ctr_para = 'para';
  ctr_se = 'se';
  ctr_senao = 'senao';
  sbrt_retorne = 'retorne';
  virg = ',';
  indicador_comeco = '->';
  sep_for = ';';
  sep_arg = '|';
  mais = '+';
  menos = '-';
  mult = '*';
  div = '/';
  atribuicao = ':=';
  ponto = '.';
  menor = '<';
  maior = '>';
  menor_igual = '<=';
  maior_igual = '>=';
  igual = '=';
  bool_nao = 'nao';
  bool_e = 'e';
  bool_ou = 'ou';
  bool_se = 'se';
  par_esq = '(';
  par_dir = ')';
  colch_esq = '[';
  colch_dir = ']';
  caractere = ''' ('\')? ascii ''';
  string = '"' [ascii - '"']* '"'; 
  numero = digito+ (',' digito+)?;
  booleano = 'verdadeiro' | 'falso'; 
  identificador = letra (letra | underscore | digito)*;
  ws = delim+;

Ignored Tokens
  ws, comentario_linha, comentario_bloco;


// ----------------------------------------------------------------------------
// Sintático.

Productions

programa = dec_variavel* dec_funcao*;

dec_variavel = tipo lista_nomes ponto;

lista_nomes = identificador virg_id_fecho*;

virg_id_fecho = virg identificador;

tipo = {tipo_base} tipo_base
      | {tipo_vetor} tipo_vetor tipo_base colch_exp_colch+;

colch_exp_colch = colch_esq exp colch_dir;

tipo_base = {tipo_num} tipo_numero 
          | {tipo_char} tipo_caractere
          | {tipo_bool} tipo_booleano;

dec_funcao = indicador_comeco? tipo_retorno identificador par_esq parametros par_dir bloco;

tipo_retorno = {tipo} tipo
              | {tipo_vazio} tipo_vazio;

parametros = {param} parametro parametro_fecho*
            | {empty};

parametro_fecho = sep_arg parametro;

parametro = tipo identificador;

bloco = bloco_i dec_variavel* comando* bloco_f;

atrib = var atribuicao exp;

lista_atrib = atrib virg_atrib_fecho*;

virg_atrib_fecho = virg atrib;

comando = {comando_casam} comando_casam
        | {comando_nao_casam} comando_nao_casam;

comando_nao_casam = {comando_se_senao} ctr_se par_esq exp par_dir [esq]:comando_nao_casam ctr_senao [dir]:comando_nao_casam
        | {comando_atrib} atrib ponto
        | {comando_retorne} sbrt_retorne exp? ponto
        | {comando_bloco} bloco
        | {comando_chamada} chamada ponto;

comando_casam = {comando_se} ctr_se par_esq exp par_dir comando
              | {comando_se_senao} ctr_se par_esq exp par_dir comando_nao_casam ctr_senao comando_casam
              | {comando_enquanto} ctr_enquanto par_esq exp par_dir comando
              | {comando_para} ctr_para par_esq [esq1]:lista_atrib [esq2]:sep_for exp [dir1]:sep_for [dir2]:lista_atrib par_dir comando
              | {comando_para_cada} ctr_para_cada par_esq tipo [esq1]:identificador ctr_para_cada_sep [esq2]:identificador par_dir comando;


var = {id} identificador
      | {var2} var colch_esq exp colch_dir;

chamada = identificador par_esq lista_exp par_dir;

numero_pos_neg = {num_pos} numero
                | {num_neg} menos numero;

lista_exp = {lista_exp} exp sep_exp_fecho*
          | {empty};

sep_exp_fecho = sep_arg exp;

exp {-> a_exp} = {exp_ou} exp_ou {-> exp_ou.a_exp};

exp_ou {-> a_exp} = {exp_ou} exp_ou bool_ou exp_e     {-> New a_exp.a_ou(exp_ou.a_exp, exp_e.a_exp)}
      | {exp_e} exp_e                                 {-> exp_e.a_exp};

exp_e {-> a_exp} = {exp_e} exp_e bool_e exp_comparacao      {-> New a_exp.a_e(exp_e.a_exp, exp_comparacao.a_exp)}
      | {exp_comparacao} exp_comparacao                     {-> exp_comparacao.a_exp};

exp_comparacao {-> a_exp} = {igual} exp_comparacao igual exp_soma_sub   {-> New a_exp.a_igual(exp_comparacao.a_exp, exp_soma_sub.a_exp)}
      | {menor_igual} exp_comparacao menor_igual exp_soma_sub           {-> New a_exp.a_menor_igual(exp_comparacao.a_exp, exp_soma_sub.a_exp)}
      | {maior_igual} exp_comparacao maior_igual exp_soma_sub           {-> New a_exp.a_maior_igual(exp_comparacao.a_exp, exp_soma_sub.a_exp)}
      | {menor} exp_comparacao menor exp_soma_sub                       {-> New a_exp.a_menor(exp_comparacao.a_exp, exp_soma_sub.a_exp)}
      | {maior} exp_comparacao maior exp_soma_sub                       {-> New a_exp.a_maior(exp_comparacao.a_exp, exp_soma_sub.a_exp)}
      | {exp_soma_sub} exp_soma_sub                                     {-> exp_soma_sub.a_exp};

exp_soma_sub {-> a_exp} = {soma} exp_soma_sub mais exp_mult_div   {-> New a_exp.a_soma(exp_soma_sub.a_exp, exp_mult_div.a_exp)}
      | {subtracao} exp_soma_sub menos exp_mult_div               {-> New a_exp.a_subtracao(exp_soma_sub.a_exp, exp_mult_div.a_exp)}
      | {exp_mult_div} exp_mult_div                               {-> exp_mult_div.a_exp};

exp_mult_div  {-> a_exp} = {mult} exp_mult_div mult exp_nao       {-> New a_exp.a_mult(exp_mult_div.a_exp, exp_nao.a_exp)}
      | {div} exp_mult_div div exp_nao                            {-> New a_exp.a_div(exp_mult_div.a_exp, exp_nao.a_exp)}
      | {exp_nao} exp_nao                                         {-> exp_nao.a_exp};

exp_nao {-> a_exp} = {exp_nao} bool_nao exp_nao             {-> exp_nao.a_exp}
      | {exp_parentese_literais} exp_parentese_literais     {-> exp_parentese_literais.a_exp};    

exp_parentese_literais {-> a_exp} = 
      {exp_parentese} par_esq exp par_dir {-> exp.a_exp}
      | {var} var                         {-> New a_exp.a_var(var)}
      | {num} numero_pos_neg              {-> New a_exp.a_num(numero_pos_neg)}
      | {char} caractere                  {-> New a_exp.a_char(caractere)}
      | {bool} booleano                   {-> New a_exp.a_bool(booleano)}
      | {string} string                   {-> New a_exp.a_string(string)}
      | {chamada} chamada                 {-> New a_exp.a_chamada(chamada)};

Abstract Syntax Tree

a_exp = {a_ou} [esq]:a_exp [dir]:a_exp
      | {a_e} [esq]:a_exp [dir]:a_exp
      | {a_igual} [esq]:a_exp [dir]:a_exp
      | {a_menor_igual} [esq]:a_exp [dir]:a_exp
      | {a_maior_igual} [esq]:a_exp [dir]:a_exp
      | {a_menor} [esq]:a_exp [dir]:a_exp
      | {a_maior} [esq]:a_exp [dir]:a_exp
      | {a_soma} [esq]:a_exp [dir]:a_exp
      | {a_subtracao} [esq]:a_exp [dir]:a_exp
      | {a_mult} [esq]:a_exp [dir]:a_exp
      | {a_div} [esq]:a_exp [dir]:a_exp
      | {a_var} var
      | {a_num} numero_pos_neg 
      | {a_char} caractere
      | {a_bool} booleano
      | {a_string} string
      | {a_chamada} chamada;