Package caju;

// ----------------------------------------------------------------------------
// Léxico.

Helpers
  digito = ['0' .. '9'];
  espaco = ' ';
  underscore = '_';
  lf = 10;
  rc = 13;
  eol = (lf | rc | lf rc);
  delim = (espaco | lf | rc);
  letra = ['A' .. 'Z'] | ['a' .. 'z'];
  ascii = [0 .. 0xffff];
  ascii_but_eol = [ascii - [lf + rc]];
  ascii_but_bracket = [ascii - '}'];

Tokens
  comentario_linha = '#' ascii_but_eol* eol;
  comentario_bloco = '{' ascii_but_bracket* '}';
  tipo_caractere = 'caractere';
  tipo_numero = 'numero';
  tipo_booleano = 'booleano';
  tipo_vetor = 'vetor';
  tipo_vazio = 'vazio';
  bloco_i = 'inicio';
  bloco_f = 'fim';
  ctr_enquanto = 'enquanto';
  ctr_para_cada = 'para cada';
  ctr_para_cada_sep = ':';
  ctr_para = 'para';
  ctr_se = 'se';
  ctr_senao = 'senao';
  sbrt_retorne = 'retorne';
  virg = ',';
  indicador_comeco = '->';
  sep_for = ';';
  sep_arg = '|';
  mais = '+';
  menos = '-';
  mult = '*';
  div = '/';
  atribuicao = ':=';
  ponto = '.';
  menor = '<';
  maior = '>';
  menor_igual = '<=';
  maior_igual = '>=';
  igual = '=';
  bool_nao = 'nao';
  bool_e = 'e';
  bool_ou = 'ou';
  bool_se = 'se';
  par_esq = '(';
  par_dir = ')';
  chave_esq = '[';
  chave_dir = ']';
  caractere = ''' ('\')? ascii ''';
  string = '"' [ascii - '"']* '"'; 
  numero = digito+ (',' digito+)?;
  booleano = 'verdadeiro' | 'falso'; 
  identificador = letra (letra | underscore | digito)*;
  ws = delim+;

Ignored Tokens
  ws, comentario_linha, comentario_bloco;


// ----------------------------------------------------------------------------
// Sintático.

Productions

programa = dec_variavel* dec_funcao*;

dec_variavel = tipo lista_nomes ponto;

lista_nomes = identificador virg_id_fecho*;

virg_id_fecho = virg identificador;

tipo = {tipo_base} tipo_base
      | {tipo_vetor} tipo_vetor tipo_base chave_esq exp chave_dir chave_exp_chave*;

chave_exp_chave = chave_esq exp chave_dir;

tipo_base = {tipo_num} numero 
          | {tipo_char} caractere
          | {tipo_bool} booleano;

dec_funcao = indicador_comeco? tipo_retorno identificador par_esq parametros par_dir bloco;

tipo_retorno = {tipo} tipo
              | {tipo_vazio} tipo_vazio;

parametros = {param} parametro parametro_fecho*
            | {empty};

parametro_fecho = sep_arg parametro;

parametro = tipo identificador;

bloco = bloco_i dec_variavel* comando* bloco_f;

atrib = var atribuicao exp;

lista_atrib = atrib virg_atrib_fecho*;

virg_atrib_fecho = virg atrib;

comando = {dec_casam} dec_casam 
         | {dec_nao_casam} dec_nao_casam;

dec_casam = {comando_se_senao_casam} ctr_se par_esq exp par_dir dec_casam ctr_senao dec_casam
            | {comando1} comando1;

dec_nao_casam = {comando_se_nao_casam} ctr_se par_esq exp par_dir comando
                | {comando_se_senao_nao_casam} ctr_se par_esq exp par_dir dec_casam ctr_senao dec_nao_casam;

comando1 = {comando_enquanto} ctr_enquanto par_esq exp par_dir comando
        | {comando_para} ctr_para par_esq lista_atrib sep_for exp sep_for lista_atrib par_dir comando
        | {comando_para_cada} ctr_para_cada par_esq tipo identificador ctr_para_cada_sep identificador par_dir comando
        | {comando_atrib} atrib ponto
        | {comando_retorne} retorne exp* ponto
        | {comando_bloco} bloco
        | {comando_chamada} chamada ponto;

var = identificador
    | var chave_esq exp chave_dir;

// resolver ambiguidade
exp = exp bool_ou exp2;

exp2 = exp2 bool_e exp3;

exp3 = bool_nao exp4;

exp4 = {exp_igual} exp4 igual exp5
      | {exp_menor_igual} exp4 menor_igual exp5 
      | {exp_maior_igual} exp4 maior_igual exp5
      | {exp_menor_igual} exp4 menor_igual exp5
      | {exp_menor} exp4 menor exp5
      | {exp_amaior} exp4 maior exp5;

exp5 = exp5 soma_sub exp6;

soma_sub = {soma} mais 
          | {subtracao} menos;

exp6 = exp6 mult_div exp7;

mult_div = {mult} mult
          | {div} div;

exp7 = {chamada} chamada 
      | {exp_parentese} exp8;

exp8 = par_esq exp par_dir 
      | {num} numero
      | {char} caractere
      | {bool} booleano;

chamada = identificador par_esq lista_exp par_dir;

lista_exp = exp sep_exp_fecho*
          | {empty};

sep_exp_fecho = sep_arg exp;
